<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[manim学习笔记]]></title>
    <url>%2F2019%2F06%2F28%2Fmanim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[3Blue1Brown,以专业数学素养和高质量的可视化数学教学闻名的YouTube频道，其中的微积分系列和线性代数系列更是外行能欣赏其形式美，内行能欣赏其内容美的佳作，帮助了许多人建立数学直觉(math intuition)层面上的更深理解 笔者最近便学习了其可视化制作的动画引擎——manim的使用，本着_学了无聊就要写笔记_ 的原则，在此稍作记录 Hello World​ 众所周知，不管是啥语言都要从最基本的最经典的”Hello World”写起 ​ 先上代码 123456789101112131415161718from manimlib.imports import *class Helloworld(Scene): def construct(self): example_text = TextMobject( "Hello World", tex_to_color_map=&#123;"Hello": RED, "World": BLUE&#125; ) example_tex = TexMobject( "\\delta S = \\delta \\int_&#123;t_1&#125;^&#123;t_2&#125; L dt = 0", ) group = VGroup(example_text, example_tex) group.arrange(DOWN) group.set_width(FRAME_WIDTH - 2 * LARGE_BUFF) self.play(Write(example_text)) self.play(Write(example_tex)) self.wait() ​ 前面的manimlib.imports是manim的自带库，基本上所有需要用到的函数都在这个库引用到的文件中有应用 ​ Helloworld是Scene的子类，如果没有特殊需要的基本都这样定义，等于设定一个幕布的效果？ ​ construct()类似于C++中的main()函数，程序的主框架都放在里面 ​ TextMobject()和TexMobject()实际上区别就是前一个支持渲染带空格的文本，后一个就是普通的$\LaTeX$（这个符号要用\LaTeX区分大小写才能渲染），需要注意的是由于python本身语法的问题，原来$\LaTeX $中的\XXX现在要改为\\\XXX才能渲染 ​ VGroup的作用好像是将多个对象有所区分的组成一个动画组，便于对他们的参数进行调整，其中的arrange应该是显示的方向，set_width是宽度设定 FRAME_WIDTH指的是屏幕宽度，LARGE_BUFF是边距，这些直接调用后参数手动微调就好 ​ self.play()是Animation中的一个函数，是生成动画效果的必备函数，在其中可以同时放置多个动画的相关函数，意为这些操作会同时进行，若是像上文代码中那样分开排列，则按照先后顺序显示 ​ Write()是绘制文本的动画函数，相似的还有ShowCreation()这个绘制几何图形的动画函数，注意这类函数一定要放在self.play()中才有效 ​ self.wait()根据字面意思就知道，是在动画末尾插入几帧以起到停顿的效果 未完待更…]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[感想]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[发现自己果然还是太幼稚了 啥也不懂，说话就乱说 说话要经过大脑 考虑事情要从大的方面考虑，更加长远、全面一些 换位思考很重要 冷静下来再考虑问题 别看轻自己，也别自以为是]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《力学》笔记]]></title>
    <url>%2F2019%2F06%2F26%2F%E3%80%8A%E5%8A%9B%E5%AD%A6%E3%80%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近朗道十卷(实际上只有九本)终于在费尽周折之后到手了 但只是瞎看看翻翻并没啥效果 所以就抽出些时间写一些笔记，辅助理解，也算个整理吧 实际就是懒得做题巩固 基本概念 自由度：唯一地确定系统位置所需独立变量的数目 广义坐标：对于$s$个自由度的系统，可以完全刻画其位置的任意$s$个变量$q_1,q_2,…,q_s$称为该系统的广义坐标 运动方程：加速度与坐标，速度的关系式 运动积分：值在运动过程中保持 恒定，且仅由 初始条件 决定的，关于描述力学系统运动状态的$2s$个变量 $q_i,\dot{q_i}(i=1,2,..,s)$ 的函数 拉格朗日函数： L(q,\dot{q}, t ) 作用量： S = \int_{t_1}^{t_2}L(q,\dot{q}, t)dt 哈密顿函数： H(p,q,t) = \sum_i p_i \dot{q_i} - L 质点系的拉格朗日函数： L=\frac{1}{2} \sum_{i,k}a_{ik}(q)\dot{q_i}\dot{q_k}-U(q) 能量： E=\sum_i\dot{q_i}\frac{\partial L}{\partial \dot{q_i}} - L \\ E=T(q,\dot{q})+U(q)=\sum_a \frac{m_av_a^2}{2}+U(\textbf{r}_1,\textbf{r}_2,...) 动量： p_i = \frac{\partial L}{\partial \dot{q_i}} \\ \textbf{P}=\sum_a \frac{\partial L}{\partial \textbf{v}_a} = \sum_a m_a\textbf{v}_a 力： F_i=\frac{\partial L}{\partial q_i} \\ 角动量： M_i=\frac{\partial L}{\partial \varphi_i} \\ \textbf{M}=\sum_a\textbf{r}_a\times\textbf{p}_a 质心： \textbf{R}=\frac{\sum m_a\textbf{r}_a}{\sum m_a} \qquad \textbf{V}=\frac{d}{dt} \textbf{R} \\ \mu = \sum m_a \qquad E=\frac{\mu V^2}{2}+E_{int} \\ \textbf{P}=\textbf{P}'+\textbf{V}\sum_a m_a \qquad \textbf{M}=\textbf{M}'+\textbf{R}\times\textbf{P} \\ L=L'+\textbf{V}\cdot\textbf{P}'+\frac{\mu V^2}{2} \qquad E=E'+\textbf{V}\cdot\textbf{P}'+\frac{\mu V^2}{2} 力学相似性: 当系统的势能是（笛卡尔）坐标的$k$次齐次函数时，有： \frac{t'}{t}=(\frac{l'}{l})^{1-k/2} \qquad \frac{v'}{v}=(\frac{l'}{l})^{k/2} \\ \frac{E'}{E}=(\frac{l'}{l})^{k} \qquad \frac{M'}{M}=(\frac{l'}{l})^{1+k/2} \\ \bar{U}=\frac{2}{k+2}E \qquad \bar{T}=\frac{k}{k+2}E 泊松括号： \{ f,g \}= \sum_k \frac{\partial f}{\partial p_k} \frac{\partial g}{\partial q_k}-\frac{\partial f}{\partial q_k} \frac{\partial g}{\partial p_k} 基本公式 最小作用量原理： \delta S = \delta \int_{t_1}^{t_2} L(q, \dot{q}, t)dt = 0 拉格朗日方程： \frac{d}{dt} \frac{\partial L}{\partial \dot{q_i}} - \frac{\partial L}{\partial q_i} = 0 哈密顿方程(正则方程)： \dot{q_i} = \frac{\partial H}{\partial p_i}, \dot{p_i} = -\frac{\partial H}{\partial q_i} 雅可比恒等式： \{ f, \{ g,h \}\} + \{ g, \{ h,f \} \} + \{ h, f,g \} \}=0 一些理解 力学系统的运动完全由最小作用量原理确定：通过求解由该原理导出的运动方程，可以得到轨道的形式以及在轨道位置与时间的函数关系 \lim L = L_A+L_B拉格朗日函数的这种可加性反映了一个事实：每一个独立部分的运动方程不可能包含与另一部分相关的物理量 L'(q,\dot{q},t)=L(q,\dot{q},t)+\frac{d}{dt}f(q,t) \\ S'=S+f(q^{(2)},t_2)-f(q^{(1)},t_1) \\ \delta S'=\delta S = 0即拉格朗日函数中可以看作_某个坐标和时间的函数$f(q,t)$对时间的全导数_ 的部分可以忽略 经典力学的基本前提：绝对时间假设和伽利略相对性原理 故容易知道 相互作用瞬间传递 时间的均匀性 $\iff$ 能量守恒定律 空间的均匀性 $\iff$ 动量守恒定律 空间的各向同性 $\iff$ 角动量守恒定律 -]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF121B]Lucky Transformation]]></title>
    <url>%2F2018%2F10%2F20%2FCF121B-Lucky-Transformation%2F</url>
    <content type="text"><![CDATA[题目描述Petya喜欢幸运数字。每个人都知道幸运数字是十进制下各位只包含$4$和$7$的正整数。例如数字$47$、$744$和$4$都是幸运数字，但$5$、$17$和$467$不是。 Petya有一个由$n$位数字组成的没有前导零的数。他用一个没有前导零的数组来表示这个数，我们称它为$d$。数组的下标从$1$开始顺序输入。Petya想要进行$k$次如下的变换:找到一个最小的$x(1&lt;=x&lt; n)$使得其满足$d_x=4$并且$d_{x+1}=7$。如果$x$是奇数，那么让$d_x=d_{x+1}=4$，否则让$d_x=d_{x+1}=7$。若没有满足条件的$x$，则数字不变。 给定初始数组和数字$k$，请你帮助Petya得出$k$次操作后的结果。 输入输出格式输入格式第一行包括两个整数$n$和$k(1&lt;=n&lt;=10^5,0&lt;=k&lt;=10^9)$，分别表示数字个数和操作次数。第二行用$n$个数字表示数组$d$,数字之间没有空格，以$d_1$开始。保证数字没有前导零。 输出格式输出一行，为操作后的结果，数字之间没有空格 说明在第一个样例中数字变换成如下序列:$4727447\to4427447\to4427477\to4427447\to4427477$在第二个样例中:$4478\to4778\to4478$ 题解仔细观察题面发现，$k$的取值远大于$n$，显然在操作的过程中出现了循环，否则就是无效操作考虑何时出现循环，当出现一个满足条件的$x$时 当$x\mod2==1$时，使$d_{x+1}=4$，显然，若此时存在$d_{x+2}==7$，由于$x\mod2==1$，所以$x+1\mod2==0$，所以使$d_{x+1}=7$，然而此时$d_x=4$，所以$x$又可以对答案造成一次贡献 当$x\mod2==0$时，使$d_{x}=7$，若存在$d_{x-1}==4$，由于$x\mod2==0$，所以$x-1\mod==1$，所以又可以转变成上面那种情况 当存在上下两种情况互相转换时，就出现循环，此时我们只需考虑$k$的奇偶性$O(1)$变换即可 代码如下 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N = 100009;int n, k, flag;int d[N];int main() &#123; scanf("%d%d", &amp;n, &amp;k); flag = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); for (int i = 1; i &lt;= n; i++) d[i] = c - '0', c = getchar(); for (int i = 1; i &lt;= n &amp;&amp; k; i++) &#123; if (d[i] == 4 &amp;&amp; d[i + 1] == 7 &amp;&amp; d[i + 2] == 7 &amp;&amp; (i &amp; 1)) k %= 2; if (d[i] == 4 &amp;&amp; d[i + 1] == 7 &amp;&amp; k) &#123; if (i &amp; 1) d[i + 1] = 4; else d[i] = 7; i -= 2, k--; &#125; &#125; for (int i = 1; i &lt;= n; i++) putchar(d[i] + '0'); return 0;&#125; 题目这么简单不要问我为什么是黑的]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI2018]归程]]></title>
    <url>%2F2018%2F10%2F11%2FNOI2018-%E5%BD%92%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[题解部分这里是原题QwQ一看到这道题 。。我。。我就不会做了 显然我们要先跑一遍最短路，得到每一个点到1的最短距离然后呢？我们要在这道题中用到一个叫做 Kruskal重构树 的黑科技，具体内容可以参照%%% 在学习了这个黑科技之后，我们来考虑一下它所要用在本题中的优秀性质。 对于任意一个非叶子结点，它的优先级小于等于它的子树中任意一个结点 换一种说法，我们在树上任选一条链，其上结点优先级具有单调性 简单的说，如果我们以海拔为关键字对边从大到小排序，然后构建出一颗Kruskal重构树，那么对于这颗树上的任意一个结点，如果它是合法的，那么它的子树中任意一个结点都是合法的也就是说，对于我们所查询的结点，我们找到它的深度最浅的并且海拔大于p的祖先，那么在这个祖先的子树中的任意一个结点我们都可以不消耗任何代价到达也就是也就是说，这颗子树中任意一个结点到1的最小代价就是这颗子树中到1最近的那个结点到1的代价 dis_{u\in subtree}=\min_{v\in subtree}dis_v没有$\sum$的题解还能叫题解吗.jpg对于如何找到它的满足条件的祖先，我们可以考虑使用我们可爱的倍增算法～～～ 附上代码.png 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include &lt;cstdio&gt; #include &lt;algorithm&gt;#include &lt;cstring&gt;struct iostream &#123; static const int _SIZE = 1 &lt;&lt; 26; char *p1, *p2; char ibuf[_SIZE], obuf[_SIZE]; iostream() : p1(ibuf), p2(obuf) &#123; #ifndef ONLINE_JUDGE freopen("testdata.in", "r", stdin); //freopen("testdata1.out", "w", stdout); #endif ibuf[fread(ibuf, 1, _SIZE, stdin)] = '\0'; &#125; ~iostream() &#123; fwrite(obuf, 1, p2 - obuf, stdout); &#125; inline char getchar() &#123; return *p1++; &#125; template &lt;typename _T&gt; iostream &amp; operator &gt;&gt; (_T &amp;x) &#123; static char c = getchar(); x = 0; bool flag = 0; while (c &lt; '0' || c &gt; '9') (c == '-') &amp;&amp; (flag = 1), c = getchar(); while (c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); (flag) &amp;&amp; (x = -x); return *this; &#125; inline void putchar(char x) &#123; *p2++ = x; &#125; template &lt;typename _T&gt; iostream &amp; operator &lt;&lt; (_T x) &#123; static char buf[19 ]; register char *p3 = buf; if (x != 0) &#123; if (x &lt; 0) putchar('-'), x = -x; while (x) &#123; *p3++ = x % 10 + '0'; x /= 10; &#125; while (p3 != buf) putchar(*--p3); &#125; else putchar('0'); putchar(' '); return *this; &#125;&#125; IO;static const int N = 200009, M = 400009 ; struct Graph &#123; int cnt; int head[N], nxt[M &lt;&lt; 1], to[M &lt;&lt; 1], val[M &lt;&lt; 1]; void add(int a, int b, int c) &#123; int u = head[a], v = ++cnt; nxt[v] = u, to[v] = b, val[v] = c; head[a] = v; &#125; void clear() &#123; cnt = 0; memset(head, 0, sizeof(head)); memset(nxt, 0, sizeof(nxt)); memset(to, 0, sizeof(to)); memset(val, 0, sizeof(val)); &#125; void print(int lim) &#123; for (int i = 1; i &lt;= lim; i++) &#123; for (int j = head[i]; j; j = nxt[j]) &#123; printf("%d -&gt; %d : %d\n", i, to[j], val[j]); &#125; &#125; &#125;&#125;;struct Edge &#123; int u, v, val; friend bool operator &lt; (Edge a, Edge b) &#123; return a.val &gt; b.val; &#125;&#125;;namespace UnionFind &#123; static int f[N &lt;&lt; 1]; int find(int x) &#123; if (f[x]) return f[x] = find(f[x]); return x; &#125; void merge(int a, int b, int fa) &#123; f[a] = f[b] = fa; &#125; void clear() &#123; memset(f, 0, sizeof(f)); &#125;&#125;namespace Dijkstra &#123; #define lson (u &lt;&lt; 1) #define rson (u &lt;&lt; 1 | 1) static int dis[N], min[N &lt;&lt; 2]; inline void pushup(int u) &#123; if (min[lson] &amp;&amp; min[rson]) min[u] = (dis[min[lson]] &lt; dis[min[rson]]) ? min[lson] : min[rson]; else if (min[lson]) min[u] = min[lson]; else if (min[rson]) min[u] = min[rson]; else min[u] = 0; &#125; void modify(int u, int L, int R, int pos, int x) &#123; if (L == R) &#123; min[u] = x; return; &#125; int mid = L + R &gt;&gt; 1; if (pos &lt;= mid) modify(lson, L, mid, pos, x); else modify(rson, mid + 1, R, pos, x); pushup(u); &#125; void Dijkstra(int s, int lim, Graph &amp;graph) &#123; for (int i = 1; i &lt;= lim; i++) dis[i] = 0x7fffffff; memset(min, 0, sizeof(min)); dis[s] = 0, modify(1, 1, lim, s, s); for (int _i = 1; _i &lt;= lim; _i++) &#123; int u = min[1]; modify(1, 1, lim, u, 0); for (int i = graph.head[u]; i; i = graph.nxt[i]) &#123; int v = graph.to[i]; if (dis[v] &gt; dis[u] + graph.val[i]) &#123; dis[v] = dis[u] + graph.val[i]; modify(1, 1, lim, v, v); &#125; &#125; &#125; &#125;&#125;struct Kruskal &#123; static const int logs = 20; int ch[N &lt;&lt; 1][2], val[N &lt;&lt; 1], min[N &lt;&lt; 1]; int f[N &lt;&lt; 1][logs + 9]; void dfs(int u) &#123; for (int i = 1; i &lt;= logs; i++) f[u][i] = f[f[u][i - 1]][i - 1]; if (!ch[u][0]) min[u] = Dijkstra::dis[u]; else &#123; dfs(ch[u][0]), dfs(ch[u][1]); min[u] = std::min(min[ch[u][0]], min[ch[u][1]]); &#125; &#125; void build(Edge *E, int lim, int m) &#123; std::sort(E + 1, E + 1 + m); for (int i = 1, j = 0; i &lt;= m, j &lt; lim - 1; i++) &#123; int fu = UnionFind::find(E[i].u), fv = UnionFind::find(E[i].v); if (fu == fv) continue; j++; val[lim + j] = E[i].val, f[fu][0] = f[fv][0] = lim + j; ch[lim + j][0] = fu, ch[lim + j][1] = fv; UnionFind::merge(fu, fv, lim + j); &#125; dfs(lim * 2 - 1); &#125; int query(int u, int p) &#123; for (int i = logs; i &gt;= 0; i--) &#123; if (!f[u][i] || val[f[u][i]] &lt;= p) continue; u = f[u][i]; &#125; return min[u]; &#125; void clear() &#123; memset(ch, 0, sizeof(ch)); memset(val, 0, sizeof(val)); memset(f, 0, sizeof(f)); memset(min, 0, sizeof(min)); &#125;&#125;;int Test, n, m, q, K, S, lastans;Edge E[M];Graph G;Kruskal T;void init() &#123; lastans = 0; G.clear(); T.clear(); UnionFind::clear();&#125;int main() &#123; IO &gt;&gt; Test; while (Test--) &#123; init(); IO &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; int u, v, l, a; IO &gt;&gt; u &gt;&gt; v &gt;&gt; l &gt;&gt; a; E[i] = (Edge) &#123;u, v, a&#125;; G.add(u, v, l), G.add(v, u, l); &#125; Dijkstra::Dijkstra(1, n, G); T.build(E, n, m); IO &gt;&gt; q &gt;&gt; K &gt;&gt; S; while (q--) &#123; int v0, p0, v, p; IO &gt;&gt; v0 &gt;&gt; p0; v = (v0 + K * lastans - 1) % n + 1; p = (p0 + K * lastans) % (S + 1); lastans = T.query(v, p); IO &lt;&lt; lastans, IO.putchar('\n'); &#125; &#125; return 0;&#125; 吐槽部分首先我想说，封装是个好东西 123456789101112131415161718192021222324252627282930313233341 #include &lt;cstdio&gt;2 #include &lt;algorithm&gt;3 #include &lt;cstring&gt;45 struct iostream &#123;53 &#125; IO;5455 static const int N = 200009, M = 400009;5657 struct Graph &#123;82 &#125;;8384 struct Edge &#123;90 &#125;;9192 namespace UnionFind &#123;107 &#125;108109 namespace Dijkstra &#123;147 &#125;148149 struct Kruskal &#123;190 &#125;;191192 int Test, n, m, q, K, S, lastans;193 Edge E[M];194 Graph G;195 Kruskal T;196197 void init() &#123;202 &#125;203204 int main() &#123;228 &#125; 这是我封装之后的代码，是不是炒鸡优美？唯一想让人吐槽的是，仔细观察你会发现，IO部分写了48行，是这篇代码中最长的部分。。。。这道题我在某谷上交了4次，第一次忘了init，第二次忘记清零cnt，第三次忘记清零lastans///然后我发现自己在初赛倒计时两天的时候颓了一天的Kruskal重构树mdzz这道题用上了我两天的积蓄，昨天刚学的线段树优化Dijkstra今天就用上了]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Kruskal重构树</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我有特殊的输入输出技巧]]></title>
    <url>%2F2018%2F10%2F09%2F%E6%88%91%E6%9C%89%E7%89%B9%E6%AE%8A%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[在现在这个卡常遍地走的时代，正常的getchar(),putchar()已经无法满足各大OIer们的需求于是巨佬们就发现了一些叫做fread(),fwrite()的东西想要作死尝试的蒟蒻我就在今天早上BaiduGoogle了一下这个东西然后就在P1001中WA了好几发。。。人生一大污点 fread()这个东西可以以字符串形式将输入文件中的东西一块一块的读进来，而且每次读取的速度贼快当然，因为是以字符串形式，你要先定义一个ibuf[]数组来存这块里头读进来的东西 123static const int _SIZE = 1 &lt;&lt; 18 | 1;static char *p1, *p2;static char ibuf[_SIZE]; 如果你怕读进来的空间不够大，那你可以考虑在重载一个getchar(),然后在里面一小块一小块读 1234567char getchar() &#123; if (p1 == p2) &#123; p2 = (p1 = buf) + fwrite(ibuf, 1, _SIZE,stdin); if (p1 == p2) return EOF; &#125; return *p1++;&#125; 或者你极其有自信不会爆空间，你也可以这样一次读进来一整个，而且这样会比上面那个快不过这个时候你数组空间当然要开大一点 123456789static const int _SIZE = 1 &lt;&lt; 26;void init()&#123; ibuf[fread(ibuf, 1, _SIZE, stdin)] = '\0';&#125;char getchar() &#123; return *p1++;&#125; 重载好getchar()之后就可以直接用之前那个read()乱水了 fwrite()这个东西和fread()讲道理差不多。。还是一次性把所有东西全部扔进输出文件里显然我们要开一个obuf[]来存我们要输出的东西 1234567void putchar(char c) &#123; *p2++ = c;&#125;void end() &#123; fwrite(obuf, 1, p2 - obuf, stdout);&#125; template这个东西嘛。。传说可以让你再也不用担心read(),write()里的变量没开大导致爆long long / unsigned long long但我Google了半天发现这东西不能返回值。。只能传址调用所以我们又要码风大改了 那我们最后扔一发板子以示友好？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;struct iostream &#123; static const int _SIZE = 1 &lt;&lt; 26; char *p1, *p2; char ibuf[_SIZE], obuf[_SIZE]; iostream() : p1(ibuf), p2(obuf) &#123; #ifndef ONLINE_JUDGE freopen("testdata.in", "r", stdin); freopen("testdata1.out", "w", stdout); #endif ibuf[fread(ibuf, 1, _SIZE, stdin)] = '\0'; &#125; ~iostream() &#123; fwrite(obuf, 1, p2 - obuf, stdout); &#125; inline char getchar() &#123; return *p1++; &#125; template &lt;typename _T&gt; iostream &amp; operator &gt;&gt; (_T &amp;x) &#123; static char c = getchar(); x = 0; bool flag = 0; while (c &lt; '0' || c &gt; '9') (c == '-') &amp;&amp; (flag = 1), c = getchar(); while (c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); (flag) &amp;&amp; (x = -x); return *this; &#125; inline void putchar(char x) &#123; *p2++ = x; &#125; template &lt;typename _T&gt; iostream &amp; operator &lt;&lt; (_T x) &#123; static char buf[19]; register char *p3 = buf; if (x != 0) &#123; if (x &lt; 0) putchar('-'), x = -x; while (x) &#123; *p3++ = x % 10 + '0'; x /= 10; &#125; while (p3 != buf) putchar(*--p3); &#125; else putchar('0'); return *this; &#125;&#125; IO;int main() &#123; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>卡常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道有趣的初赛题(1)]]></title>
    <url>%2F2018%2F10%2F08%2F%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E5%88%9D%E8%B5%9B%E9%A2%98-1%2F</url>
    <content type="text"><![CDATA[题目描述已知一个数列$ U_1,U_2,U_3,…U_n,… $往往可以找到一个最小的$k$值和$ k $个数:$ s_1,s_2,…,s_k $,使得数列从某项开始都满足: U_{n+k}=a_1U_{n+k-1}+a_2U_{n+k-2}+...+a_kU_n （A）例如对斐波那契数列$1,1,2,3,5,…$可以发现：当$k=2,a_1=1,a_2=1$时，从第3项起(即$n\ge1$)都满足$U_{n+2}=U_{n+1}+U_n$。 试对数列$1^2,2^2,3^2,…,n^2,…$ 求$k$和$a_1,a_2,…,a_k$使得$(A)$成立。 大力枚举讨论我们考虑枚举$k$ 当$k=1$时 由题得: (n+1)^2=a_1n^2 \\ \therefore n^2+2n+1=a_1n^2显然无解 当$k=2$时由题得: (n+2)^2=a_1(n+1)^2+a_2n \\ \therefore n^2+4n+4=(a_1+a_2)n^2+2a_1n+a_1 \\ \therefore \begin{cases} a_1+a_2=1 \\ 2a_1=4 \\ a_1=4 \end{cases} \\显然无解 当$k=3$时 由题得: (n+3)^2=a_1(n+2)^2+a_2(n+1)^2+a_3n^2 \\ \therefore n^2+6n+9=(a_1+a_2+a_3)n^2+(4a_1+2a_2)n+(4a_1+a_2) \\ \therefore \begin{cases} a_1+a_2+a_3=1 \\ 4a_1+2a_2=6 \\ 4a_1+a_2=9 \end{cases} \\ \therefore \begin{cases} a_1=3 \\ a_2=-3 \\ a_3=1 \\ \end{cases} \\检验: LHS=(n+3)^2 \\ RHS=3(n+2)^2-3(n+1)^2+n^2=n^2+6n+9=(n+3)^2综上所述: k=3,a_1=3,a_2=-3,a_3=1 严谨证明考虑题目要求的本质上是这个方程: (n+k+1)^2=\sum_{i=1}^ka_i(n+k-i+1)^2等价于: (n+k+1)^2=\sum_{i=1}^ka_i(n+i)^2 \\ \therefore n^2+(2k+2)n+(k+1)^2=\sum_{i=1}^ka_in^2+2a_i×i×n+a_i×i^2 \\ \therefore \begin{cases} \sum_{i=1}^ka_in^2=1 \\ \sum_{i=1}^ka_i×i×n=k+1 \\ \sum_{i=1}^ka_i×i^2=(k+1)^2 \\ \end{cases}显然当该方程组有唯一解时，$k=3$ 以上]]></content>
      <categories>
        <category>初赛</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2014]旅行]]></title>
    <url>%2F2018%2F10%2F08%2FSDOI2014-%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[这里是原题QwQ听说这题是动态开点线段树模板题？观察一下题面，显然先上一发树剖，好像是对每一种宗教开一颗线段树，然后维护区间和和区间最大值。。。虽然我是来练动态开点线段树板子的，考虑到fhq Treap极为好写，我还是不要脸的使用了fhq Treap来维护我们可以对每一个宗教开一颗fhq Treap: 第一个操作就是将节点换一棵树，那一个erase加一个insert就行了 第二个操作是改变一个点的点权，我是采取erase出来之后直接修改value，pushup之后再insert回去的方法这样好写 第三个操作我们在链上向上跳的时候询问一下这段区间内的权值和即可 第四个操作同操作三，询问区间最大值更新总的来说其实不难想，就是把两个数据结构写写好套一套就行了注意细节 说好来练动态开点线段树的呢？ 附上我丑陋的代码？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include &lt;cstdio&gt; #include &lt;algorithm&gt;namespace IO&#123; int read() &#123; char c = getchar(); int x = 0; bool flag = 0; while (c &lt; '0' || c &gt; '9') (c == '-') &amp;&amp; (flag = 1), c = getchar(); while (c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); (flag) &amp;&amp; (x = -x); return x; &#125; void write(int x) &#123; if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0'); &#125; void file() &#123; #ifndef ONLINE_JUDGE freopen("2.in", "r", stdin); freopen("testdata1.out", "w", stdout); #endif &#125;&#125; using namespace IO;const int N = 100009;int n, q, cnt;int head[N], nxt[N &lt;&lt; 1], to[N &lt;&lt; 1];int w[N], c[N], dep[N], fa[N], son[N], id[N], top[N], siz[N];int rt[N], val[N], max[N], ch[N][2], key[N], sum[N];namespace Treap &#123; inline void pushup(int u) &#123; max[u] = std::max(std::max(max[ch[u][0]], max[ch[u][1]]), val[u]); sum[u] = sum[ch[u][0]] + sum[ch[u][1]] + val[u]; &#125; inline void desNode(int u) &#123; ch[u][0] = ch[u][1] = 0, siz[u] = 1, max[u] = sum[u] = val[u]; &#125; int merge(int l, int r) &#123; if (!l || !r) return l ^ r; if (key[l] &lt; key[r]) &#123; ch[l][1] = merge(ch[l][1], r); pushup(l); return l; &#125; else &#123; ch[r][0] = merge(l, ch[r][0]); pushup(r); return r; &#125; &#125; void split(int u, int x, int &amp;l, int &amp;r) &#123; if (!u) l = r = 0; else &#123; if (u &lt;= x) l = u, split(ch[l][1], x, ch[l][1], r); else r = u, split(ch[r][0], x, l, ch[r][0]); pushup(u); &#125; &#125; void insert(int u, int x) &#123; int t1, t2; split(rt[x], u, t1, t2); rt[x] = merge(merge(t1, u), t2); &#125; void erase(int u, int x) &#123; int t1, t2, t3; split(rt[x], u, t1, t2); split(t1, u - 1, t1, t3); rt[x] = merge(merge(t1, merge(ch[t3][0], ch[t3][1])), t2); desNode(t3); &#125;&#125; using namespace Treap;void print(int u) &#123; if (ch[u][0]) print(ch[u][0]); printf("%d : %d %d %d %d %d\n", u, val[u], sum[u], ch[u][0], ch[u][1], key[u]); if (ch[u][1]) print(ch[u][1]);&#125;char getopt() &#123; char c = getchar(); while (c != 'C' &amp;&amp; c != 'W' &amp;&amp; c != 'S' &amp;&amp; c != 'Q' &amp;&amp; c != 'M') c = getchar(); return c;&#125;void add(int a, int b) &#123; int u = head[a], v = ++cnt; nxt[v] = u, to[v] = b; head[a] = v;&#125;void dfs1(int u, int pre, int depth) &#123; fa[u] = pre, dep[u] = depth, siz[u] = 1; for (int i = head[u]; i; i = nxt[i]) &#123; if (to[i] == pre) continue; dfs1(to[i], u, depth + 1); siz[u] += siz[to[i]]; if (siz[to[i]] &gt; siz[son[u]]) son[u] = to[i]; &#125;&#125;void dfs2(int u, int t) &#123; top[u] = t, id[u] = ++cnt; max[id[u]] = sum[id[u]] = val[id[u]] = w[u], key[id[u]] = rand() % 19260817, rt[c[u]] = merge(rt[c[u]], id[u]); if (!son[u]) return; dfs2(son[u], t); for (int i = head[u]; i; i = nxt[i]) &#123; if (to[i] == fa[u] || to[i] == son[u]) continue; dfs2(to[i], to[i]); &#125;&#125;int get_sum(int l, int r, int x) &#123; int t1, t2, t3, ans; split(rt[x], l - 1, t1, t2); split(t2, r, t2, t3); ans = sum[t2]; rt[x] = merge(merge(t1,t2), t3); return ans;&#125;int get_max(int l, int r, int x) &#123; int t1, t2, t3, ans; split(rt[x], l - 1, t1, t2); split(t2, r, t2, t3); ans = max[t2]; rt[x] = merge(merge(t1, t2), t3); return ans;&#125;int main() &#123; file(); n = read(), q = read(); for (int i = 1; i &lt;= n; i++) w[i] = read(), c[i] = read(); for (int i = 1; i &lt; n; i++) &#123; int u = read(), v = read(); add(u, v); add(v, u); &#125; dfs1(1, 0, 1), cnt = 0, dfs2(1, 1); while (q--) &#123; char opt1 = getopt(), opt2 = getopt(); if (opt1 == 'C' &amp;&amp; opt2 == 'C') &#123; int x = read(), y = read(); erase(id[x], c[x]); insert(id[x], c[x] = y); &#125; else if (opt1 == 'C' &amp;&amp; opt2 == 'W') &#123; int t1, t2, t3, x = read(), y = read(); erase(id[x], c[x]); val[id[x]] = y, pushup(id[x]); insert(id[x], c[x]); &#125; else if (opt1 == 'Q' &amp;&amp; opt2 == 'S') &#123; int u = read(), v = read(), x = c[u], ans = 0; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) std::swap(u, v); ans += get_sum(id[top[u]], id[u], x); u = fa[top[u]]; &#125; if (dep[u] &lt; dep[v]) std::swap(u, v); ans += get_sum(id[v], id[u], x); write(ans), putchar('\n'); &#125; else &#123; int u = read(), v = read(), x = c[u], ans = 0; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) std::swap(u, v); ans = std::max(ans, get_max(id[top[u]], id[u], x)); u = fa[top[u]]; &#125; if (dep[u] &lt; dep[v]) std::swap(u, v); ans = std::max(ans, get_max(id[v], id[u], x)); write(ans), putchar('\n'); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>fhq Treap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F30%2FHello-World%2F</url>
    <content type="text"><![CDATA[123456#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; cout &lt;&lt; "Hello World!" &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
</search>
